[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "isExtraImport": true,
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "isExtraImport": true,
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "do_cvariance",
        "importPath": "commands.image_characteristics.cvariance",
        "description": "commands.image_characteristics.cvariance",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvariance",
        "documentation": {}
    },
    {
        "label": "do_cvariance",
        "importPath": "commands.image_characteristics.cvariance",
        "description": "commands.image_characteristics.cvariance",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvariance",
        "documentation": {}
    },
    {
        "label": "do_cvariance",
        "importPath": "commands.image_characteristics.cvariance",
        "description": "commands.image_characteristics.cvariance",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvariance",
        "documentation": {}
    },
    {
        "label": "PIL",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PIL",
        "description": "PIL",
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "do_mean_square_error",
        "importPath": "commands.mean_square_error",
        "description": "commands.mean_square_error",
        "isExtraImport": true,
        "detail": "commands.mean_square_error",
        "documentation": {}
    },
    {
        "label": "do_mean_square_error",
        "importPath": "commands.mean_square_error",
        "description": "commands.mean_square_error",
        "isExtraImport": true,
        "detail": "commands.mean_square_error",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "load_image",
        "importPath": "input_output",
        "description": "input_output",
        "isExtraImport": true,
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "save_image",
        "importPath": "input_output",
        "description": "input_output",
        "isExtraImport": true,
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "load_image",
        "importPath": "input_output",
        "description": "input_output",
        "isExtraImport": true,
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "save_image",
        "importPath": "input_output",
        "description": "input_output",
        "isExtraImport": true,
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "do_brightness",
        "importPath": "commands.brightness",
        "description": "commands.brightness",
        "isExtraImport": true,
        "detail": "commands.brightness",
        "documentation": {}
    },
    {
        "label": "do_help",
        "importPath": "commands.help",
        "description": "commands.help",
        "isExtraImport": true,
        "detail": "commands.help",
        "documentation": {}
    },
    {
        "label": "do_contrast",
        "importPath": "commands.contrast",
        "description": "commands.contrast",
        "isExtraImport": true,
        "detail": "commands.contrast",
        "documentation": {}
    },
    {
        "label": "do_negative",
        "importPath": "commands.negative",
        "description": "commands.negative",
        "isExtraImport": true,
        "detail": "commands.negative",
        "documentation": {}
    },
    {
        "label": "do_horizontal_flip",
        "importPath": "commands.horizontal",
        "description": "commands.horizontal",
        "isExtraImport": true,
        "detail": "commands.horizontal",
        "documentation": {}
    },
    {
        "label": "do_vertical_flip",
        "importPath": "commands.vertical",
        "description": "commands.vertical",
        "isExtraImport": true,
        "detail": "commands.vertical",
        "documentation": {}
    },
    {
        "label": "do_diagonal_flip",
        "importPath": "commands.diagonal",
        "description": "commands.diagonal",
        "isExtraImport": true,
        "detail": "commands.diagonal",
        "documentation": {}
    },
    {
        "label": "do_adaptive_noise_filter",
        "importPath": "commands.adaptive",
        "description": "commands.adaptive",
        "isExtraImport": true,
        "detail": "commands.adaptive",
        "documentation": {}
    },
    {
        "label": "do_shrinking",
        "importPath": "commands.shrinking",
        "description": "commands.shrinking",
        "isExtraImport": true,
        "detail": "commands.shrinking",
        "documentation": {}
    },
    {
        "label": "do_enlargement",
        "importPath": "commands.enlargement",
        "description": "commands.enlargement",
        "isExtraImport": true,
        "detail": "commands.enlargement",
        "documentation": {}
    },
    {
        "label": "do_min_filer",
        "importPath": "commands.min",
        "description": "commands.min",
        "isExtraImport": true,
        "detail": "commands.min",
        "documentation": {}
    },
    {
        "label": "do_max_filer",
        "importPath": "commands.max",
        "description": "commands.max",
        "isExtraImport": true,
        "detail": "commands.max",
        "documentation": {}
    },
    {
        "label": "do_peak_mse",
        "importPath": "commands.peak_mse",
        "description": "commands.peak_mse",
        "isExtraImport": true,
        "detail": "commands.peak_mse",
        "documentation": {}
    },
    {
        "label": "do_signal_to_noise",
        "importPath": "commands.signal_to_noise_ratio",
        "description": "commands.signal_to_noise_ratio",
        "isExtraImport": true,
        "detail": "commands.signal_to_noise_ratio",
        "documentation": {}
    },
    {
        "label": "do_max_difference",
        "importPath": "commands.max_difference",
        "description": "commands.max_difference",
        "isExtraImport": true,
        "detail": "commands.max_difference",
        "documentation": {}
    },
    {
        "label": "do_psnr",
        "importPath": "commands.psnr",
        "description": "commands.psnr",
        "isExtraImport": true,
        "detail": "commands.psnr",
        "documentation": {}
    },
    {
        "label": "do_histogram",
        "importPath": "commands.histogram",
        "description": "commands.histogram",
        "isExtraImport": true,
        "detail": "commands.histogram",
        "documentation": {}
    },
    {
        "label": "do_hhyper",
        "importPath": "commands.hhyper",
        "description": "commands.hhyper",
        "isExtraImport": true,
        "detail": "commands.hhyper",
        "documentation": {}
    },
    {
        "label": "do_cmean",
        "importPath": "commands.image_characteristics.cmean",
        "description": "commands.image_characteristics.cmean",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cmean",
        "documentation": {}
    },
    {
        "label": "do_cmean",
        "importPath": "commands.image_characteristics.cmean",
        "description": "commands.image_characteristics.cmean",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cmean",
        "documentation": {}
    },
    {
        "label": "do_cstdev",
        "importPath": "commands.image_characteristics.cstdev",
        "description": "commands.image_characteristics.cstdev",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cstdev",
        "documentation": {}
    },
    {
        "label": "do_cstdev",
        "importPath": "commands.image_characteristics.cstdev",
        "description": "commands.image_characteristics.cstdev",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cstdev",
        "documentation": {}
    },
    {
        "label": "do_cvarcoi",
        "importPath": "commands.image_characteristics.cvarcoi",
        "description": "commands.image_characteristics.cvarcoi",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvarcoi",
        "documentation": {}
    },
    {
        "label": "do_cvarcoi",
        "importPath": "commands.image_characteristics.cvarcoi",
        "description": "commands.image_characteristics.cvarcoi",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvarcoi",
        "documentation": {}
    },
    {
        "label": "do_cvarcoii",
        "importPath": "commands.image_characteristics.cvarcoii",
        "description": "commands.image_characteristics.cvarcoii",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvarcoii",
        "documentation": {}
    },
    {
        "label": "do_cvarcoii",
        "importPath": "commands.image_characteristics.cvarcoii",
        "description": "commands.image_characteristics.cvarcoii",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cvarcoii",
        "documentation": {}
    },
    {
        "label": "do_casyco",
        "importPath": "commands.image_characteristics.casyco",
        "description": "commands.image_characteristics.casyco",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.casyco",
        "documentation": {}
    },
    {
        "label": "do_casyco",
        "importPath": "commands.image_characteristics.casyco",
        "description": "commands.image_characteristics.casyco",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.casyco",
        "documentation": {}
    },
    {
        "label": "do_cflattening",
        "importPath": "commands.image_characteristics.cflattening",
        "description": "commands.image_characteristics.cflattening",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cflattening",
        "documentation": {}
    },
    {
        "label": "do_cflattening",
        "importPath": "commands.image_characteristics.cflattening",
        "description": "commands.image_characteristics.cflattening",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.cflattening",
        "documentation": {}
    },
    {
        "label": "do_sedghesharp",
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "isExtraImport": true,
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "do_sedghesharp",
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "isExtraImport": true,
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "do_kirsh_operator",
        "importPath": "commands.kirsh_operator",
        "description": "commands.kirsh_operator",
        "isExtraImport": true,
        "detail": "commands.kirsh_operator",
        "documentation": {}
    },
    {
        "label": "do_mask_filter",
        "importPath": "commands.mask_filter",
        "description": "commands.mask_filter",
        "isExtraImport": true,
        "detail": "commands.mask_filter",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "do_centropy",
        "importPath": "commands.image_characteristics.centropy",
        "description": "commands.image_characteristics.centropy",
        "isExtraImport": true,
        "detail": "commands.image_characteristics.centropy",
        "documentation": {}
    },
    {
        "label": "do_casyco",
        "kind": 2,
        "importPath": "commands.image_characteristics.casyco",
        "description": "commands.image_characteristics.casyco",
        "peekOfCode": "def do_casyco(image: np.ndarray, args:dict[str, str]) -> float:\n    ch = args.get('-channel', 'y')\n    image = extract_channel(image, channel=ch)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")\n    m = np.arange(256, dtype=np.float64)\n    s1 = float(np.sum(h * m))\n    s2 = float(np.sum(h * (m ** 2)))\n    s3 = float(np.sum(h * (m ** 3)))",
        "detail": "commands.image_characteristics.casyco",
        "documentation": {}
    },
    {
        "label": "do_centropy",
        "kind": 2,
        "importPath": "commands.image_characteristics.centropy",
        "description": "commands.image_characteristics.centropy",
        "peekOfCode": "def do_centropy(image: np.ndarray, args: dict[str, str]) -> float:\n    channel = args.get('-channel', 'y')\n    image = extract_channel(image, channel=channel)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")\n    p = h / n\n    p_nonzero = p[p > 0]\n    ent = -np.sum(p_nonzero * np.log2(p_nonzero))\n    return float(ent)",
        "detail": "commands.image_characteristics.centropy",
        "documentation": {}
    },
    {
        "label": "do_cflattening",
        "kind": 2,
        "importPath": "commands.image_characteristics.cflattening",
        "description": "commands.image_characteristics.cflattening",
        "peekOfCode": "def do_cflattening(image, args:dict[str, str]) :\n    ch = args.get('-channel', 'y')\n    image = extract_channel(image, channel=ch)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")\n    m = np.arange(256, dtype=np.float64)\n    s1 = float(np.sum(h * m))\n    s2 = float(np.sum(h * (m ** 2)))\n    s3 = float(np.sum(h * (m ** 3)))",
        "detail": "commands.image_characteristics.cflattening",
        "documentation": {}
    },
    {
        "label": "do_cmean",
        "kind": 2,
        "importPath": "commands.image_characteristics.cmean",
        "description": "commands.image_characteristics.cmean",
        "peekOfCode": "def do_cmean(image: np.ndarray, args: Dict[str, str]) -> float:\n    if image.size == 0:\n        return float(\"nan\")\n    if image.ndim not in (2, 3):\n        raise ValueError(\"Expected 2D (gray) or 3D (RGB/RGBA) image\")\n    channel = args.get(\"-channel\", \"y\").upper()\n    if image.ndim == 2:\n        return float(np.mean(image.astype(np.float64)))\n    imgf = image[..., :3].astype(np.float64) \n    if channel in (\"R\", \"G\", \"B\"):",
        "detail": "commands.image_characteristics.cmean",
        "documentation": {}
    },
    {
        "label": "do_cstdev",
        "kind": 2,
        "importPath": "commands.image_characteristics.cstdev",
        "description": "commands.image_characteristics.cstdev",
        "peekOfCode": "def do_cstdev(image: np.ndarray, args:dict[str, str]) -> float:\n    cvar = do_cvariance(image, args)\n    if np.isnan(cvar):\n        return float(\"nan\")\n    return float(np.sqrt(cvar))",
        "detail": "commands.image_characteristics.cstdev",
        "documentation": {}
    },
    {
        "label": "do_cvarcoi",
        "kind": 2,
        "importPath": "commands.image_characteristics.cvarcoi",
        "description": "commands.image_characteristics.cvarcoi",
        "peekOfCode": "def do_cvarcoi(image: np.ndarray, args: dict[str, str]) -> float:\n    \"\"\"\n    Variation coefficient I: sigma / mean\n    Liczone z jednego histogramu (wariancja populacyjna).\n    \"\"\"\n    ch = (args.get(\"-channel\", \"y\") or \"y\").lower()\n    image = extract_channel(image, channel=ch)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")",
        "detail": "commands.image_characteristics.cvarcoi",
        "documentation": {}
    },
    {
        "label": "_EPS",
        "kind": 5,
        "importPath": "commands.image_characteristics.cvarcoi",
        "description": "commands.image_characteristics.cvarcoi",
        "peekOfCode": "_EPS = 1e-12  # osłona na mean≈0 i szum numeryczny\ndef do_cvarcoi(image: np.ndarray, args: dict[str, str]) -> float:\n    \"\"\"\n    Variation coefficient I: sigma / mean\n    Liczone z jednego histogramu (wariancja populacyjna).\n    \"\"\"\n    ch = (args.get(\"-channel\", \"y\") or \"y\").lower()\n    image = extract_channel(image, channel=ch)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:",
        "detail": "commands.image_characteristics.cvarcoi",
        "documentation": {}
    },
    {
        "label": "do_cvarcoii",
        "kind": 2,
        "importPath": "commands.image_characteristics.cvarcoii",
        "description": "commands.image_characteristics.cvarcoii",
        "peekOfCode": "def do_cvarcoii(image: np.ndarray, args: dict[str, str]) -> float:\n    channel = args.get('-channel', 'y')\n    image = extract_channel(image, channel=channel)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")\n    h = h.astype(np.float64, copy=False)\n    num = float(np.dot(h,h))\n    val = num / (n*n)\n    return float(val)",
        "detail": "commands.image_characteristics.cvarcoii",
        "documentation": {}
    },
    {
        "label": "do_cvariance",
        "kind": 2,
        "importPath": "commands.image_characteristics.cvariance",
        "description": "commands.image_characteristics.cvariance",
        "peekOfCode": "def do_cvariance(image: np.ndarray, args:dict[str, str]) -> float:\n    ch = args.get('-channel', 'y')\n    image = extract_channel(image, channel=ch)\n    h, cdf, n = compute_histogram(image)\n    if n == 0:\n        return float(\"nan\")\n    m = np.arange(256, dtype=np.float64)\n    s1 = float(np.sum(h * m)) \n    s2 = float(np.sum(h * (m ** 2))) \n    mean = s1 / n",
        "detail": "commands.image_characteristics.cvariance",
        "documentation": {}
    },
    {
        "label": "do_adaptive_noise_filter",
        "kind": 2,
        "importPath": "commands.adaptive",
        "description": "commands.adaptive",
        "peekOfCode": "def do_adaptive_noise_filter(img: np.ndarray, args: dict):\n    sMax = int(args.get(\"-sMax\", 9))\n    sMin = int(args.get(\"-sMin\", 3))\n    if (sMax % 2 == 0 or sMin % 2 == 0):\n        raise ValueError(\"Window size must be an odd number\")\n    if not (sMax >= sMin >= 3):\n        raise ValueError(\"Window size must be sMax>=sMin>=3\")\n    orig_dtype = img.dtype\n    if img.ndim == 3:\n        channels = []",
        "detail": "commands.adaptive",
        "documentation": {}
    },
    {
        "label": "do_brightness",
        "kind": 2,
        "importPath": "commands.brightness",
        "description": "commands.brightness",
        "peekOfCode": "def do_brightness(img: np.ndarray, args: dict) -> np.ndarray:\n    const = int(args.get('-const'))\n    if const is None:\n        print(\"No constant given. \\n\")\n        return\n    if not (-255 <= const <= 255):\n        print(\"Constant must be between -255 and 255. \\n\")\n        return\n    else:\n        newImg = img + const",
        "detail": "commands.brightness",
        "documentation": {}
    },
    {
        "label": "do_contrast",
        "kind": 2,
        "importPath": "commands.contrast",
        "description": "commands.contrast",
        "peekOfCode": "def do_contrast(img: np.ndarray, args: dict) -> np.ndarray:\n    val = args.get('-factor')\n    if val is None:\n        raise ValueError(\"No factor given.\\n\")\n    try:\n        factor = float(val)\n    except:\n        raise Exception(\"Factor must be a floating point number\")\n    if factor <= 0:\n        raise ValueError(\"Factor must be higher than 0\")",
        "detail": "commands.contrast",
        "documentation": {}
    },
    {
        "label": "do_diagonal_flip",
        "kind": 2,
        "importPath": "commands.diagonal",
        "description": "commands.diagonal",
        "peekOfCode": "def do_diagonal_flip(img: np.ndarray, args: dict) -> np.ndarray:\n    return np.flip(img, (0,1))",
        "detail": "commands.diagonal",
        "documentation": {}
    },
    {
        "label": "do_enlargement",
        "kind": 2,
        "importPath": "commands.enlargement",
        "description": "commands.enlargement",
        "peekOfCode": "def do_enlargement(img: np.ndarray, args: dict) -> np.ndarray:\n    factor = int(args.get('-factor'))\n    return np.repeat(np.repeat(img, factor, 0), factor, 1)",
        "detail": "commands.enlargement",
        "documentation": {}
    },
    {
        "label": "do_help",
        "kind": 2,
        "importPath": "commands.help",
        "description": "commands.help",
        "peekOfCode": "def do_help():\n    print(\"Available commands: \\n \\n\")\n    print(\"--help \\n Prints this message with all commands and their arguments\")\n    print(\"--brightness \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n -const=<value>    Brightness adjustment constant (integer between -255 and 255) \\n\")\n    print(\"--contrast \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n -factor=<value>   Contrast adjustment factor (float, e.g., 1.2 for increase, 0.8 for decrease) \\n\")\n    print(\"--negative \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n\")\n    print(\"--hflip \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n\")\n    print(\"--vflip \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n\")\n    print(\"--dflip \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n\")\n    print(\"--adaptive \\n -input=<path>    Path to the input image \\n -output=<path>   Path to save the image \\n -sMin=<value default 3> minimum window size \\n -sMax=<value default 9> maximum window size\")",
        "detail": "commands.help",
        "documentation": {}
    },
    {
        "label": "do_hhyper",
        "kind": 2,
        "importPath": "commands.hhyper",
        "description": "commands.hhyper",
        "peekOfCode": "def do_hhyper(img: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    if img.dtype != np.uint8:\n        raise ValueError(\"Expected uint8 image\")\n    gmin = int(args.get('-gmin', 64))\n    gmax = int(args.get('-gmax', 255))\n    # Gray\n    if img.ndim == 2:\n        ch = img\n        _, cdf, n = compute_histogram(ch, num_bins=256)\n        if n == 0:",
        "detail": "commands.hhyper",
        "documentation": {}
    },
    {
        "label": "do_histogram",
        "kind": 2,
        "importPath": "commands.histogram",
        "description": "commands.histogram",
        "peekOfCode": "def do_histogram(\n    img: np.ndarray,\n    args: dict[str, str]\n) -> Image.Image:\n    # --- args ---\n    ch         = args.get('-channel', 'y').lower()\n    num_bins   = 256\n    plot_h     = int(args.get('-height', '200'))\n    plot_w     = int(args.get('-width',  str(num_bins)))\n    bar_color  = args.get('-color', 'black')",
        "detail": "commands.histogram",
        "documentation": {}
    },
    {
        "label": "do_horizontal_flip",
        "kind": 2,
        "importPath": "commands.horizontal",
        "description": "commands.horizontal",
        "peekOfCode": "def do_horizontal_flip(img: np.ndarray, args: dict) -> np.ndarray:\n    return np.flip(img, axis=1)",
        "detail": "commands.horizontal",
        "documentation": {}
    },
    {
        "label": "do_kirsh_operator",
        "kind": 2,
        "importPath": "commands.kirsh_operator",
        "description": "commands.kirsh_operator",
        "peekOfCode": "def do_kirsh_operator(img: np.ndarray, args: dict) -> np.ndarray:\n    if img.ndim == 2:\n        return kirsh(img)\n    else:\n        R = img[...,0]\n        G = img[...,1]\n        B = img[...,2]\n        Y = 0.299*R + 0.587*G + 0.114*B\n        return kirsh(Y)\ndef kirsh(img:np.ndarray) -> np.ndarray:",
        "detail": "commands.kirsh_operator",
        "documentation": {}
    },
    {
        "label": "kirsh",
        "kind": 2,
        "importPath": "commands.kirsh_operator",
        "description": "commands.kirsh_operator",
        "peekOfCode": "def kirsh(img:np.ndarray) -> np.ndarray:\n    output = np.zeros_like(img, dtype=np.float32)\n    for i in range(1, img.shape[0]-1):\n        for j in range(1, img.shape[1]-1):\n            window = img[i-1:i+2, j-1:j+2].astype(np.int32)\n            A = [window[0,0], window[0,1], window[0,2], window[1,2], window[2,2], window[2,1], window[2,0], window[1,0]]\n            g = [1]\n            for n in range(0, 8):\n                S = A[n] + A[(n+1)%8] + A[(n+2)%8]\n                T = A[(n+3)%8] + A[(n+4)%8] + A[(n+5)%8] + A[(n+6)%8] + A[(n+7)%8]",
        "detail": "commands.kirsh_operator",
        "documentation": {}
    },
    {
        "label": "do_mask_filter",
        "kind": 2,
        "importPath": "commands.mask_filter",
        "description": "commands.mask_filter",
        "peekOfCode": "def do_mask_filter(image: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    kernel_str = args.get(\"kernel\", \"K1\")\n    K = _parse_kernel3x3(kernel_str)\n    x = image.astype(np.float32)\n    if x.ndim == 2:\n        y = _do_mask_filter_single_channel(x, K)\n        return np.clip(np.rint(y), 0, 255).astype(np.uint8)\n    if x.ndim == 3 and x.shape[2] == 3:\n        chans = [_do_mask_filter_single_channel(x[..., c], K) for c in range(3)]\n        y = np.stack(chans, axis=-1)",
        "detail": "commands.mask_filter",
        "documentation": {}
    },
    {
        "label": "do_max_filer",
        "kind": 2,
        "importPath": "commands.max",
        "description": "commands.max",
        "peekOfCode": "def do_max_filer(img: np.ndarray, args: dict) -> np.ndarray:\n    window_size_str = args.get(\"-window\", 3)\n    window_size = int(window_size_str)\n    if (window_size%2==0 or window_size%2==0):\n        raise ValueError(\"Window size cannot be a number divisible by 2\")\n    m = int((window_size - 1) / 2)\n    img2 = np.copy(img)\n    if img.ndim == 3:\n        for c in range(img.shape[2]):\n            for i in range(m, img.shape[0] - m):",
        "detail": "commands.max",
        "documentation": {}
    },
    {
        "label": "do_max_difference",
        "kind": 2,
        "importPath": "commands.max_difference",
        "description": "commands.max_difference",
        "peekOfCode": "def do_max_difference(original_img: np.ndarray, other_img: np.ndarray):\n    if original_img.shape != other_img.shape:\n        raise ValueError(\"The images must have the same sizes.\")\n    md = np.max(np.abs(original_img.astype('float') - other_img.astype('float')))\n    return md",
        "detail": "commands.max_difference",
        "documentation": {}
    },
    {
        "label": "do_mean_square_error",
        "kind": 2,
        "importPath": "commands.mean_square_error",
        "description": "commands.mean_square_error",
        "peekOfCode": "def do_mean_square_error(orignal_img: np.ndarray, other_img: np.ndarray):\n    if orignal_img.shape != other_img.shape:\n        raise ValueError(\"The images must have the same sizes.\")\n    difference = orignal_img.astype(\"float\") - other_img.astype(\"float\")\n    squared = np.square(difference)\n    mse = np.mean(squared)\n    return mse",
        "detail": "commands.mean_square_error",
        "documentation": {}
    },
    {
        "label": "do_min_filer",
        "kind": 2,
        "importPath": "commands.min",
        "description": "commands.min",
        "peekOfCode": "def do_min_filer(img: np.ndarray, args: dict) -> np.ndarray:\n    window_size_str = args.get(\"-window\", 3)\n    window_size = int(window_size_str)\n    if (window_size%2==0 or window_size%2==0):\n        raise ValueError(\"Window size cannot be a number divisible by 2\")\n    m = int((window_size - 1) / 2)\n    img2 = np.copy(img)\n    if img.ndim == 3:\n        for c in range(img.shape[2]):\n            for i in range(m, img.shape[0] - m):",
        "detail": "commands.min",
        "documentation": {}
    },
    {
        "label": "do_negative",
        "kind": 2,
        "importPath": "commands.negative",
        "description": "commands.negative",
        "peekOfCode": "def do_negative(img: np.ndarray, args: dict) -> np.ndarray:\n    x = np.arange(256, dtype=np.float32)\n    lut = 255 - x\n    lut = np.clip(lut, 0, 255).astype(np.uint8)\n    idx = img.astype(np.uint8, copy = False)\n    return np.take(lut, idx)",
        "detail": "commands.negative",
        "documentation": {}
    },
    {
        "label": "do_peak_mse",
        "kind": 2,
        "importPath": "commands.peak_mse",
        "description": "commands.peak_mse",
        "peekOfCode": "def do_peak_mse(original_img:np.ndarray, other_img: np.ndarray):\n    max_value = np.max(original_img)\n    if max_value == 0:\n        pmse = 0\n    else:\n        pmse = do_mean_square_error(original_img, other_img)/np.square(max_value)\n    return pmse",
        "detail": "commands.peak_mse",
        "documentation": {}
    },
    {
        "label": "do_psnr",
        "kind": 2,
        "importPath": "commands.psnr",
        "description": "commands.psnr",
        "peekOfCode": "def do_psnr(original: np.array, new:np.array):\n    original = original.astype(np.float64)\n    new = new.astype(np.float64)\n    if new.shape!=original.shape:\n        raise ValueError(\"Images need to be the same type and size!\")\n    if original.ndim==3:\n        channels = []\n        for ch in range(new.shape[2]):\n            calculated = _do_psnr_per_channel(original[:, :, ch], new[:, :, ch])\n            channels.append(calculated)",
        "detail": "commands.psnr",
        "documentation": {}
    },
    {
        "label": "do_sedghesharp",
        "kind": 2,
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "peekOfCode": "def do_sedghesharp(image: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    kernel_key = args.get(\"kernel\", \"K1\").upper()\n    if kernel_key not in K_MAP:\n        raise ValueError(\"Kernel not defined ('K1' | 'K2' | 'K3')\")\n    K = K_MAP[kernel_key]\n    x = image.astype(np.float32)\n    if x.ndim == 2:\n        y = _do_sedghesharp_single_channel(x, K)\n        return np.clip(np.rint(y), 0, 255).astype(np.uint8)\n    if x.ndim == 3 and x.shape[2] == 3:",
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "K1",
        "kind": 5,
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "peekOfCode": "K1 = np.array([[0, -1,  0],\n               [-1, 5, -1],\n               [0, -1,  0]], dtype=np.float32)\nK2 = np.array([[-1, -1, -1],\n               [-1,  9, -1],\n               [-1, -1, -1]], dtype=np.float32)\nK3 = np.array([[ 1, -2,  1],\n               [-2,  5, -2],\n               [ 1, -2,  1]], dtype=np.float32)\nK_MAP = {\"K1\": K1, \"K2\": K2, \"K3\": K3}",
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "K2",
        "kind": 5,
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "peekOfCode": "K2 = np.array([[-1, -1, -1],\n               [-1,  9, -1],\n               [-1, -1, -1]], dtype=np.float32)\nK3 = np.array([[ 1, -2,  1],\n               [-2,  5, -2],\n               [ 1, -2,  1]], dtype=np.float32)\nK_MAP = {\"K1\": K1, \"K2\": K2, \"K3\": K3}\ndef do_sedghesharp(image: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    kernel_key = args.get(\"kernel\", \"K1\").upper()\n    if kernel_key not in K_MAP:",
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "K3",
        "kind": 5,
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "peekOfCode": "K3 = np.array([[ 1, -2,  1],\n               [-2,  5, -2],\n               [ 1, -2,  1]], dtype=np.float32)\nK_MAP = {\"K1\": K1, \"K2\": K2, \"K3\": K3}\ndef do_sedghesharp(image: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    kernel_key = args.get(\"kernel\", \"K1\").upper()\n    if kernel_key not in K_MAP:\n        raise ValueError(\"Kernel not defined ('K1' | 'K2' | 'K3')\")\n    K = K_MAP[kernel_key]\n    x = image.astype(np.float32)",
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "K_MAP",
        "kind": 5,
        "importPath": "commands.sedghesharp",
        "description": "commands.sedghesharp",
        "peekOfCode": "K_MAP = {\"K1\": K1, \"K2\": K2, \"K3\": K3}\ndef do_sedghesharp(image: np.ndarray, args: dict[str, str]) -> np.ndarray:\n    kernel_key = args.get(\"kernel\", \"K1\").upper()\n    if kernel_key not in K_MAP:\n        raise ValueError(\"Kernel not defined ('K1' | 'K2' | 'K3')\")\n    K = K_MAP[kernel_key]\n    x = image.astype(np.float32)\n    if x.ndim == 2:\n        y = _do_sedghesharp_single_channel(x, K)\n        return np.clip(np.rint(y), 0, 255).astype(np.uint8)",
        "detail": "commands.sedghesharp",
        "documentation": {}
    },
    {
        "label": "do_shrinking",
        "kind": 2,
        "importPath": "commands.shrinking",
        "description": "commands.shrinking",
        "peekOfCode": "def do_shrinking(img: np.ndarray, args:dict) -> np.ndarray:\n    factor = int(args.get('-factor'))\n    return img[::factor,::factor] #przejdź przez cały array z step =factor (pomijamy co druga kolumne i co drugi rzad)",
        "detail": "commands.shrinking",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  do_signal_to_noise(original_img: np.ndarray, other_img: np.ndarray):\n    if original_img.shape != other_img.shape:\n        raise ValueError(\"The images must have the same sizes.\")\n    signal = np.sum(np.square(original_img.astype('float')))\n    noise = np.sum(np.square(original_img.astype('float') - other_img.astype('float')))\n    if noise == 0:\n        snr = np.inf\n    else:\n        snr = 10 * np.log10(signal / noise)    \n    return snr"
        },
        "kind": 2,
        "importPath": "commands.signal_to_noise_ratio",
        "description": "commands.signal_to_noise_ratio",
        "peekOfCode": "def  do_signal_to_noise(original_img: np.ndarray, other_img: np.ndarray):\n    if original_img.shape != other_img.shape:\n        raise ValueError(\"The images must have the same sizes.\")\n    signal = np.sum(np.square(original_img.astype('float')))\n    noise = np.sum(np.square(original_img.astype('float') - other_img.astype('float')))\n    if noise == 0:\n        snr = np.inf\n    else:\n        snr = 10 * np.log10(signal / noise)    \n    return snr",
        "detail": "commands.signal_to_noise_ratio",
        "documentation": {}
    },
    {
        "label": "do_vertical_flip",
        "kind": 2,
        "importPath": "commands.vertical",
        "description": "commands.vertical",
        "peekOfCode": "def do_vertical_flip(img: np.ndarray, args: dict) -> np.ndarray:\n    return np.flip(img, axis=0)",
        "detail": "commands.vertical",
        "documentation": {}
    },
    {
        "label": "compute_histogram",
        "kind": 2,
        "importPath": "utils.compute_histogram",
        "description": "utils.compute_histogram",
        "peekOfCode": "def compute_histogram(img: np.ndarray,  num_bins: int = 256) -> tuple[np.ndarray, np.ndarray, int]:\n    if img.ndim != 2:\n        raise ValueError(\"Input must be a 2D array representing a single image channel.\")\n    h = np.bincount(img.ravel(), minlength=num_bins).astype(np.int64) #zlicza wystąpienia wartości pikseli\n    h = h[:num_bins]  # histogram ma mieć dokładnie num_bins elementów\n    cdf = np.cumsum(h) # skumulowana suma histogramu\n    n = int(h.sum()) # całkowita liczba pikseli\n    cdf = cdf/n if n > 0 else cdf # normalizacja CDF\n    return h, cdf, n",
        "detail": "utils.compute_histogram",
        "documentation": {}
    },
    {
        "label": "extract_channel",
        "kind": 2,
        "importPath": "utils.extract_channel",
        "description": "utils.extract_channel",
        "peekOfCode": "def extract_channel(img: np.ndarray, channel: str) -> np.ndarray:\n    if img.dtype != np.uint8:\n        raise TypeError(\"Oczekuję uint8.\")\n    if img.ndim == 2:  \n        return img\n    if img.ndim != 3 or img.shape[2] < 3:\n        raise ValueError(\"Expected an image with at least 3 channels.\")\n    ch = channel.lower()\n    R, G, B = img[...,0], img[...,1], img[...,2]\n    if ch == \"r\": return R",
        "detail": "utils.extract_channel",
        "documentation": {}
    },
    {
        "label": "as_gray",
        "kind": 2,
        "importPath": "utils.to_luminance",
        "description": "utils.to_luminance",
        "peekOfCode": "def as_gray(image: np.ndarray, channel: str=\"y\") -> np.ndarray:\n    if image.ndim == 2:\n        return image\n    elif image.ndim == 3:\n        rgb = image[..., :3]\n        if channel == \"y\":\n            x = np.tensordot(rgb.astype(np.float64), _YW, axes=([-1], [0]))\n        else:\n            idx = {\"r\": 0, \"g\": 1, \"b\": 2}.get(channel.lower())\n            if idx is None:",
        "detail": "utils.to_luminance",
        "documentation": {}
    },
    {
        "label": "_YW",
        "kind": 5,
        "importPath": "utils.to_luminance",
        "description": "utils.to_luminance",
        "peekOfCode": "_YW = np.array([0.2126, 0.7152, 0.0722], dtype=np.float64)\ndef as_gray(image: np.ndarray, channel: str=\"y\") -> np.ndarray:\n    if image.ndim == 2:\n        return image\n    elif image.ndim == 3:\n        rgb = image[..., :3]\n        if channel == \"y\":\n            x = np.tensordot(rgb.astype(np.float64), _YW, axes=([-1], [0]))\n        else:\n            idx = {\"r\": 0, \"g\": 1, \"b\": 2}.get(channel.lower())",
        "detail": "utils.to_luminance",
        "documentation": {}
    },
    {
        "label": "load_image",
        "kind": 2,
        "importPath": "input_output",
        "description": "input_output",
        "peekOfCode": "def load_image(path: str) -> np.ndarray:\n    try:\n        img = Image.open(path)\n        if img.mode == \"P\":\n            img = img.convert(\"RGB\") # paletted image\n        elif img.mode == \"LA\": #grayscale with alpha\n            img = img.convert(\"L\")\n        elif img.mode == \"RGBA\": #rgb with alpha\n            img = img.convert(\"RGB\") #drop alpha channel\n        elif img.mode not in (\"L\", \"RGB\"):",
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "save_image",
        "kind": 2,
        "importPath": "input_output",
        "description": "input_output",
        "peekOfCode": "def save_image(path: str, img):\n    if isinstance(img, np.ndarray):\n        save_image_arr(path, img)\n    elif isinstance(img, PIL.Image.Image):\n        save_image_pil(path, img)\n    else:\n        raise TypeError(\"Unsupported image type for saving.\")\ndef save_image_arr(path: str, arr: np.ndarray):\n    try:\n        newImg = Image.fromarray(arr.astype(np.uint8))",
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "save_image_arr",
        "kind": 2,
        "importPath": "input_output",
        "description": "input_output",
        "peekOfCode": "def save_image_arr(path: str, arr: np.ndarray):\n    try:\n        newImg = Image.fromarray(arr.astype(np.uint8))\n        newImg.show() \n        newImg.save(path)\n    except Exception as e:\n        print(\"Error saving image. Check the file path. \\n\")\n        print(e)\n        raise SystemExit(3)\ndef save_image_pil(path:str, img: PIL.Image.Image):",
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "save_image_pil",
        "kind": 2,
        "importPath": "input_output",
        "description": "input_output",
        "peekOfCode": "def save_image_pil(path:str, img: PIL.Image.Image):\n    try:\n        img.save(path)\n    except Exception as e:\n        print(\"Error saving image. Check the file path. \\n\")\n        print(e)\n        raise SystemExit(3  )",
        "detail": "input_output",
        "documentation": {}
    },
    {
        "label": "COMMANDS",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "COMMANDS = {\n    \"--brightness\": do_brightness,\n    \"--help\": do_help,\n    \"--contrast\": do_contrast,\n    \"--hflip\": do_horizontal_flip,\n    \"--negative\": do_negative,\n    \"--vflip\": do_vertical_flip,\n    \"--dflip\": do_diagonal_flip,\n    \"--adaptive\": do_adaptive_noise_filter,\n    \"--shrink\": do_shrinking,",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SIMILARITY",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "SIMILARITY = {\n    \"--mse\": do_mean_square_error,\n    \"--pmse\": do_peak_mse,\n    \"--snr\": do_signal_to_noise,\n    \"--psnr\": do_psnr,\n    \"--md\": do_max_difference\n}\nCHARACTERISTICS = {\n    \"--cmean\": do_cmean,\n    \"--cvariance\": do_cvariance,",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "CHARACTERISTICS",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "CHARACTERISTICS = {\n    \"--cmean\": do_cmean,\n    \"--cvariance\": do_cvariance,\n    \"--cstdev\": do_cstdev,\n    \"--cvarcoi\": do_cvarcoi,\n    \"--cvarcoii\": do_cvarcoii,\n    \"--casyco\": do_casyco,\n    \"--cflattening\": do_cflattening\n}\nif len(sys.argv) == 1:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "command = sys.argv[1]\nif command == '--help':\n    do_help()\nelse:\n    if len(sys.argv) == 2:\n        print(\"Too few command line parameters given.\\n\")\n        sys.exit()\n    args = {}\n    for arg in sys.argv[2:]:\n        if '=' in arg:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "compute_all_metrics",
        "kind": 2,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "def compute_all_metrics(img) -> dict[str, float]:\n    \"\"\"Liczy wszystkie metryki dla obrazu i zwraca dict {nazwa: wartosc}.\"\"\"\n    out = {}\n    for name, fn in METRICS:\n        try:\n            v = float(fn(img, {}))\n        except Exception as e:\n            # Jak coś padnie (np. dzielenie przez 0), nie wywracaj batcha\n            v = float(\"nan\")\n        out[name] = v",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "def main():\n    original = load_image(IMG_PATH)\n    base_metrics = compute_all_metrics(original)\n    print(\"DEBUG\")\n    # przygotuj CSV\n    with open(CSV_PATH, \"w\", newline=\"\") as f:\n        writer = csv.writer(f)\n        writer.writerow([\n            \"kernel\",\n            \"metric\",",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "IMG_PATH",
        "kind": 5,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "IMG_PATH = \"./images/lenac.bmp\"\nOUT_DIR = Path(\"./test_folder/\")\nCSV_PATH = OUT_DIR / \"metrics_sedghesharp.csv\"\nKERNELS = [\"K1\", \"K2\", \"K3\"]  \nMETRICS = [\n    (\"cmean\",      do_cmean),\n    (\"cvariance\",  do_cvariance),\n    (\"cstdev\",     do_cstdev),\n    (\"cvarcoi\",    do_cvarcoi),\n    (\"cvarcoii\",   do_cvarcoii),",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "OUT_DIR = Path(\"./test_folder/\")\nCSV_PATH = OUT_DIR / \"metrics_sedghesharp.csv\"\nKERNELS = [\"K1\", \"K2\", \"K3\"]  \nMETRICS = [\n    (\"cmean\",      do_cmean),\n    (\"cvariance\",  do_cvariance),\n    (\"cstdev\",     do_cstdev),\n    (\"cvarcoi\",    do_cvarcoi),\n    (\"cvarcoii\",   do_cvarcoii),\n    (\"casyco\",     do_casyco),",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "CSV_PATH",
        "kind": 5,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "CSV_PATH = OUT_DIR / \"metrics_sedghesharp.csv\"\nKERNELS = [\"K1\", \"K2\", \"K3\"]  \nMETRICS = [\n    (\"cmean\",      do_cmean),\n    (\"cvariance\",  do_cvariance),\n    (\"cstdev\",     do_cstdev),\n    (\"cvarcoi\",    do_cvarcoi),\n    (\"cvarcoii\",   do_cvarcoii),\n    (\"casyco\",     do_casyco),\n    (\"cflattening\",do_cflattening),",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "KERNELS",
        "kind": 5,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "KERNELS = [\"K1\", \"K2\", \"K3\"]  \nMETRICS = [\n    (\"cmean\",      do_cmean),\n    (\"cvariance\",  do_cvariance),\n    (\"cstdev\",     do_cstdev),\n    (\"cvarcoi\",    do_cvarcoi),\n    (\"cvarcoii\",   do_cvarcoii),\n    (\"casyco\",     do_casyco),\n    (\"cflattening\",do_cflattening),\n    (\"centropy\",   do_centropy),",
        "detail": "sedgesharp_batch",
        "documentation": {}
    },
    {
        "label": "METRICS",
        "kind": 5,
        "importPath": "sedgesharp_batch",
        "description": "sedgesharp_batch",
        "peekOfCode": "METRICS = [\n    (\"cmean\",      do_cmean),\n    (\"cvariance\",  do_cvariance),\n    (\"cstdev\",     do_cstdev),\n    (\"cvarcoi\",    do_cvarcoi),\n    (\"cvarcoii\",   do_cvarcoii),\n    (\"casyco\",     do_casyco),\n    (\"cflattening\",do_cflattening),\n    (\"centropy\",   do_centropy),\n]",
        "detail": "sedgesharp_batch",
        "documentation": {}
    }
]